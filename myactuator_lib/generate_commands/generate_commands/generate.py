# # MyActuatorMotor.py
# # By: Nathan Adkins 
# # email: npa00003@mix.wvu.edu
# # WVU URC 

# import re

# def main():

#     manual_file_path = 'myactuator_lib/generate_commands/generate_commands/manual_contents.txt'
#     myactuator_manual_file = open(manual_file_path, 'r')

#     generated_file_path = 'myactuator_lib/motor.py'
#     generated_file = open(generated_file_path, 'w')

#     base_class_file_path = 'myactuator_lib/generate_commands/generate_commands/_base_motor.py'

#     method_pattern = r'^2\..*\s\(0x[0-9a-fA-F][0-9a-fA-F]\)$'
#     can_hex_pattern = r'^DATA.*0x[0-9a-fA-F][0-9a-fA-F]$'

#     read_lines = myactuator_manual_file.readlines()
#     written_lines: list[str] = []

#     def extract_func_name(line_string: str) -> str: # extracts and cleans the commands into function names 

#         replacements = {
#             '.' : '',
#             ' ' : '_',
#             '-' : '_',
#             '__' : '_'
#         }
#         cleaned_string = re.sub(r'\d+|\([^)]*\)', '', line_string) # regex for digits, or text in parentheses

#         for key,value in replacements.items(): # fulfilling all replacements for python method validity
#             cleaned_string = cleaned_string.replace(key,value)

#         cleaned_string = cleaned_string[1:-2] # removing first and last characters (both underscores)

#         return cleaned_string
    
    
#     def extract_can_hex(line_string: str) -> str:
#         return (str(line_string[len(line_string)-5:len(line_string)-1])) # Taking just the byte portion of the string
    
#     def create_valid_py_func(function_name: str) -> str: # add def, params, and return type
#         return f'\tdef {function_name}(self, can_parameters: list[CanDataParameter]) -> can.Message:\n'
    
#     # File Starting content
#     written_lines.append('# This file was autogenerated by "generate.py" found under the "generate_commands" folder of "myactuator_lib"\n')
#     with open(base_class_file_path, 'r') as file:
#         written_lines.extend(file.readlines())
    
#     written_lines.append('\n\n')

#     for index, line in enumerate(read_lines):

#         if re.match(method_pattern,line): 

#             valid_function_def = create_valid_py_func(extract_func_name(line))
#             written_lines.append(valid_function_def)


#             written_lines.append(f'\t\tcan_data_constructor = CanData()\n')
#             for internal_line in read_lines[index:]:
#                 if re.match(can_hex_pattern,internal_line):
#                     hex_byte = extract_can_hex(internal_line)
#                     if hex_byte != '0x00':
#                         written_lines.append(f'\t\tcan_data_constructor.initial_byte = {hex_byte} \n')
#                     break
#             written_lines.append(f'\t\tcan_data_constructor.parameter_list = can_parameters\n')
#             written_lines.append(f'\t\tself._create_can_message(can_data_constructor)\n\n')

#     generated_file.writelines(written_lines)
#     generated_file.writelines('\n')
#     generated_file.writelines('class Motor():\n')
#     generated_file.writelines('\tdef __init__(self, arbitration_id: int):\n')
#     generated_file.writelines('\t\tsuper().__init__(arbitration_id)\n')



# if __name__ == '__main__':
#     main()